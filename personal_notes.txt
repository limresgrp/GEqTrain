Check jarpaty 101 train
- Deactivate all extra pieces and train vanilla
- overfit 100 obs

Meta learm notes
Make eval script fast and easy
My notes
Initial commit
Def data for fast exp
Finish diagnostic setup
Continuous debug
Run tests

- GO HAM ON EXPERIMENTS/think to architecture<-focus on this/tuning etc

- example.yaml file with comments to be uploaded

- wandb log of gradients, act funcs, etc <- do list
- act func in stack of scalarMLPs: vect of activations of dim L+1
- fix edgewise attention


tasks:
- compare against other descriptors: https://singroup.github.io/dscribe/latest/index.html?
- Jctc paper data pipeline for qm9 splits
- [pag 7 of https://arxiv.org/pdf/2003.03123 for comparison]
- ? try reading from smiles
- misato and atom3d dsets -> Train on misato test on qm9: Qm features from misato FOR qm predictions!

------------------------------------------------------------------------------------------------------------------------------------------

ISNT ALLEGRO BIASED TOWARD LOCALITY IN LARGE SYSTEMS? CAN WE BIAS IT TOWARD LIGAND ONLY SYS?

In allegro the total energy of the sys is computed instead of sum of atom energies, but as a sum of energies defined by the features vectors that live on the edges
Idea: split scalar and tensor prod op s.t. we avoid mixing those and thus achieving better efficiency
invariant/equivariant tracks
a lot of scalars control tensor op -> equivariance at lest cost

Idea: to compute edge-repr_(ij, l) (ij start/end node, l=layer idx) we do weighted tp of (edge-repr_(ij,l), SH of all other edges staring from i)
rephrased via bilinearity into edge-repr_(ij, l) and "environment" of node i

cutoff range and model capacity are here made indipendent
idea: decouple capacity form cutoff range .... here it is done by this splitting/focus on what to compute with scalar and what to compute with geom tensors


- when u add a key to the yaml u need to parse it in config, it is not automatic
- when u create a module u must provide:
    - irreps_in: input irreps from the previous module, taken automatically from prev module
        if not provided it is out of prev module
    - irreps_out: output irreps of current module, if not provided outs same of irreps_in (?)
    - field str cuz _init_irreps MUST be called: - my_irreps_in: the actual data selected from data: pass as input in ctor a str field
        field: key of irreps_in dict that selects/define which o3.Irreps are inpt to current modul
